input {
  # TCP input for direct Logstash appender from Spring Boot
  tcp {
    port => 5000
    codec => json_lines
    tags => ["spring-boot-tcp"]
  }

  # File input for reading log files
  file {
    path => "/logs/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => multiline {
      pattern => "^%{TIMESTAMP_ISO8601}"
      negate => true
      what => "previous"
    }
    tags => ["spring-boot-file"]
  }

  # JSON log files
  file {
    path => "/logs/*.json"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => json
    tags => ["spring-boot-json"]
  }
}

filter {
  # Parse Spring Boot logs
  if "spring-boot-file" in [tags] {
    grok {
      match => {
        "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{NUMBER:pid} --- \[%{DATA:thread}\] %{DATA:logger} : %{GREEDYDATA:log_message}"
      }
    }

    date {
      match => ["timestamp", "yyyy-MM-dd HH:mm:ss.SSS", "ISO8601"]
      target => "@timestamp"
    }
  }

  # Handle JSON logs from TCP or file
  if [level] {
    mutate {
      uppercase => ["level"]
    }
  }

  # Extract service name
  mutate {
    add_field => { "service" => "travellight" }
    add_field => { "environment" => "development" }
  }

  # Parse exception stack traces
  if [stack_trace] {
    mutate {
      gsub => ["stack_trace", "\n", " "]
    }
  }

  # Extract user information from MDC
  if [mdc] {
    ruby {
      code => "
        mdc = event.get('mdc')
        if mdc.is_a?(Hash)
          mdc.each do |key, value|
            event.set('mdc_' + key, value)
          end
        end
      "
    }
  }

  # Add actionCategory based on action field
  if [action] {
    if [action] =~ /LOGIN|LOGOUT/ {
      mutate { add_field => { "actionCategory" => "LOGIN" } }
    } else if [action] =~ /RESERVATION/ {
      mutate { add_field => { "actionCategory" => "RESERVATION" } }
    } else if [action] =~ /PAYMENT/ {
      mutate { add_field => { "actionCategory" => "PAYMENT" } }
    } else if [action] =~ /ERROR/ {
      mutate { add_field => { "actionCategory" => "ERROR" } }
    } else if [action] =~ /PAGE_VIEW/ {
      mutate { add_field => { "actionCategory" => "PAGE_VIEW" } }
    }
  }

  # Add geo-location for IP addresses (if available)
  if [clientIp] {
    geoip {
      source => "clientIp"
      target => "geoip"
    }
  }

  # Remove unnecessary fields
  mutate {
    remove_field => ["host", "path"]
  }
}

output {
  # Output to Elasticsearch
  elasticsearch {
    hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
    index => "travellight-logs-%{+YYYY.MM.dd}"
    document_type => "_doc"
  }

  # Debug output to stdout (can be disabled in production)
  stdout {
    codec => rubydebug
  }
}
